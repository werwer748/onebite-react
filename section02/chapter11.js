/**
 * 동기와 비동기
 * 작업을 처리하는 영역 -> 스레드
 * 동기: 작업이 순차적으로 진행
 * 비동기: 작업을 순서대로 처리하지 않는다. 앞선 작업의 완료 여부와 상관없이 다음 작업을 진행한다.
 *
 * 자바스크립트는 싱글 스레드 -> 기본적으로 동기적으로 코드를 실행한다.
 * 동기 방식의 치명적 단점? -> 중간에 오래걸리는 작업이 있을 경우 다음 작업이 늦어지고 결국 프로그램의 퍼포먼스가 떨어진다.
 * JAVA, C++ 등은 멀티 스레드를 통해 이러한 문제를 해결한다.
 * 자바스크립트는 싱글스레드이기 때문에 이러한 문제를 해결하기 위해 비동기 방식을 사용한다.
 * 이럴 때 비동기 작업의 결과물을 어떻게 처리할 것인가? -> 콜백함수
 */
console.log(1);

// 비동기 적으로 작동하는 함수를 써보자
setTimeout(() => {
  console.log(2);
}, 3000);

console.log(3);
/**
 * 1 -> 3 -> 2 순으로 출력된다. 2는 3초 뒤에 출력된다.
 * 1을 출력하고 setTimeout 타이머만 실행해놓고 바로 다음함수로 넘어간다.
 * 3을 출력하고 3초가 지나면 setTimeout이 실행되어 2를 출력한다.
 *
 * 뭔가 병렬적으로 작동하는것처럼 보인다.
 * 스레드는 하나밖에 없는데..?
 * 자바스크립트 엔진은 비동기 작업을 위해 Web APIs라는 웹브라우저가 관리하는 영역을 사용한다.
 * -> 이 Web APIs가 실제로 JS 비동기 작업들이 실행되는 영역이라는 뜻
 *
 * 코드를 동기적으로 실행하다가 비동기함수를 만나면
 * Web APIs에게 콜백함수와 함께 해당 작업을 넘겨주고 다음 코드를 실행한다.
 * 이렇게 Wen APIs에 넘긴 작업이 종료되면 콜백함수를 자바스크립트로 다시 넘겨주고
 * 자바스크립트 엔진은 돌려받은 콜백함수를 실행한다.
 *
 * Web APIs는 비동기 작업을 처리하고,
 * Task Queue는 완료된 작업의 콜백을 보관하며,
 * Event Loop는 이 콜백들을 실행하는 역할
 */

/**
 * 자바스크립트의 실행 순서는 다음과 같습니다
 *
 * 1. 함수 실행: 함수가 호출되면 콜 스택(Call Stack)에 쌓인다
 * 2. 이벤트 루프(Event Loop): 함수가 비동기 작업을 포함하고 있다면, 비동기 작업을 Web APIs로 넘깁니다. 동기 작업은 콜 스택에서 바로 처리됩니다.
 * 3. Web APIs: 비동기 작업이 완료되면, 해당 작업의 콜백 함수를 Task Queue로 보냅니다. -> 이거완전 클로져.. ㄷㄷㄷ
 * 4. Task Queue: 콜백 함수가 Task Queue에 대기합니다.
 * 5. 이벤트 루프(Event Loop): 콜 스택이 비어 있으면, 이벤트 루프가 Task Queue에서 콜백 함수를 가져와 콜 스택에 쌓고 실행합니다.
 */
